use bevy::prelude::*;

pub struct Theme
{
	pub background: Color,
	pub on_background: Color,

	pub primary: Color,
	pub on_primary: Color,
	pub primary_container: Color,
	pub on_primary_container: Color,

	pub secondary: Color,
	pub on_secondary: Color,
	pub secondary_container: Color,
	pub on_secondary_container: Color,

	pub tertiary: Color,
	pub on_tertiary: Color,
	pub tertiary_container: Color,
	pub on_tertiary_container: Color,

	pub disabled: Color,
	pub on_disabled: Color,
}

// See https://m3.material.io/foundations/accessible-design/patterns#c06040d0-f7dd-43d8-af92-384bbb3b0544
pub const CONTRAST_ACCESIBILITY_RATIO: f64 = 4.5;

pub fn is_contrast_accessible(color1: Color, color2: Color) -> bool
{
	get_contrast_ratio(color1, color2) >= CONTRAST_ACCESIBILITY_RATIO
}
pub trait ShiftColour
{
	fn lighten(self, amount: f32) -> Self;
	fn darken(self, amount: f32) -> Self;
}

impl ShiftColour for Color
{
	fn lighten(self, amount: f32) -> Self
	{
		let Color::Hsla { hue, saturation, lightness, alpha } = self.as_hsla()
			else { unreachable!("Color::as_hsla() returned a non-HSLA color") };
		Color::hsla(hue, saturation, lightness + amount, alpha)
	}

	fn darken(self, amount: f32) -> Self
	{
		let Color::Hsla { hue, saturation, lightness, alpha } = self.as_hsla()
			else { unreachable!("Color::as_hsla() returned a non-HSLA color") };
		Color::hsla(hue, saturation, lightness - amount, alpha)
	}

}

impl Theme
{
	fn is_accessible(&self)
	{
		assert!(is_contrast_accessible(self.background, self.on_background));
		assert!(is_contrast_accessible(self.primary, self.on_primary));
		assert!(is_contrast_accessible(self.primary_container, self.on_primary_container));
		assert!(is_contrast_accessible(self.secondary, self.on_secondary));
		assert!(is_contrast_accessible(self.secondary_container, self.on_secondary_container));
		assert!(is_contrast_accessible(self.tertiary, self.on_tertiary));
		assert!(is_contrast_accessible(self.tertiary_container, self.on_tertiary_container));
		assert!(is_contrast_accessible(self.disabled, self.on_disabled));
	}
}

pub mod colours
{
	use once_cell::sync::Lazy;
	use super::*;
	// Primary, HEX: #202030
	pub static RAISIN_BLACK: Lazy<Color> = Lazy::new(|| Color::hex("202030").unwrap());
	// Secondary, HEX: #39304A
	pub static  ENGLISH_VIOLET: Lazy<Color> = Lazy::new(|| Color::hex("39304A").unwrap());
	// Tertiary, HEX: #635C51
	pub static  WALNUT_BROWN: Lazy<Color> = Lazy::new(|| Color::hex("635C51").unwrap());
}

pub mod themes
{
	use once_cell::sync::Lazy;
	use super::*;
	pub static  DARK: Lazy<Theme> = Lazy::new
	(
		||
		Theme
		{
			background: Color::BLACK,
			on_background: Color::WHITE,

			primary: colours::RAISIN_BLACK.lighten(0.75),
			on_primary: *colours::RAISIN_BLACK,
			primary_container: colours::RAISIN_BLACK.lighten(0.33),
			on_primary_container: colours::RAISIN_BLACK.lighten(0.9),

			secondary: colours::ENGLISH_VIOLET.lighten(0.75),
			on_secondary: *colours::ENGLISH_VIOLET,
			secondary_container: colours::ENGLISH_VIOLET.lighten(0.66),
			on_secondary_container: colours::ENGLISH_VIOLET.lighten(0.9),

			tertiary: colours::WALNUT_BROWN.lighten(0.75),
			on_tertiary: *colours::WALNUT_BROWN,
			tertiary_container: colours::WALNUT_BROWN.lighten(0.66),
			on_tertiary_container: colours::WALNUT_BROWN.lighten(0.9),

			disabled: Color::GRAY,
			on_disabled: Color::WHITE
		}
	);
}
// TODO: Remove this warning when the function has been verified or rewritten.
/// WARNING: This entire function was generated by ChatGPT and GitHub Copilot,
pub fn get_contrast_ratio(color1: Color, color2: Color) -> f64
{
	// Convert RGBA values to relative luminance
	fn relative_luminance(color: Color) -> f64
	{
		let Color::Rgba { red, green, blue, .. } = color.as_rgba()
			else { unreachable!("Color is not RGBA") };
		let r = red as f64;
		let g = green as f64;
		let b = blue as f64;
		let r_l = if r <= 0.03928 { r / 12.92 } else { ((r + 0.055) / 1.055).powf(2.4) };
		let g_l = if g <= 0.03928 { g / 12.92 } else { ((g + 0.055) / 1.055).powf(2.4) };
		let b_l = if b <= 0.03928 { b / 12.92 } else { ((b + 0.055) / 1.055).powf(2.4) };
		0.2126 * r_l + 0.7152 * g_l + 0.0722 * b_l
	}

	fn mix_colors(color1: Color, color2: Color) -> Color
	{
		let Color::Rgba { red: r1, green: g1, blue: b1, alpha: a1 } = color1.as_rgba()
			else { unreachable!("Color is not RGBA") };
		let Color::Rgba { red: r2, green: g2, blue: b2, alpha: a2 } = color2.as_rgba()
			else { unreachable!("Color is not RGBA") };
		let r = ( r1 + ( r2 * ( 1.0 - a1 ) ) ) / ( a1 + a2 * ( 1.0 - a1 ) );
		let g = ( g1 + ( g2 * ( 1.0 - a1 ) ) ) / ( a1 + a2 * ( 1.0 - a1 ) );
		let b = ( b1 + ( b2 * ( 1.0 - a1 ) ) ) / ( a1 + a2 * ( 1.0 - a1 ) );
		let a = a1;
		Color::Rgba { red: r, green: g, blue: b, alpha: a }
	}

		// Calculate the contrast ratio with color mixing
		let mixed_color1 = mix_colors(color1, color2);
		let mixed_color2 = mix_colors(color2, color1);
		let l1 = relative_luminance(mixed_color1);
		let l2 = relative_luminance(mixed_color2);
		if l1 > l2
		{
			(l1 + 0.05) / (l2 + 0.05)
		}
		else
		{
			(l2 + 0.05) / (l1 + 0.05)
		}
}

#[cfg(test)]
mod tests
{
	#[test]
	fn default_themes_are_accessible()
	{
		use super::*;
		themes::DARK.is_accessible();
	}
}
